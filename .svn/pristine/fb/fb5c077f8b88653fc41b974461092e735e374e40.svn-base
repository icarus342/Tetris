/*
 * TCSS 305 – Winter 2015
 * Assignment 6 - Tetris
 */

package gui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.util.List;
import java.util.Map;
import java.util.Observable;
import java.util.Observer;
import java.util.TreeMap;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.KeyStroke;
import javax.swing.Timer;

import model.Board;
import model.Board.BoardData;
import model.Point;

/**
 * The panel the displays the game state of Tetris.
 * 
 * @author Justin Arnett (jarnett@uw.edu)
 * @version 01 March 2015
 */
@SuppressWarnings("serial")
public class GamePanel extends JPanel implements Observer {

    /** Font size of game over message. */
    private static final int FONT_SIZE = 30;
    /** The string for the left key binding map. */
    private static final String LEFT_STRING = "left";
    /** The string for the right key binding map. */
    private static final String RIGHT_STRING = "right";
    /** The string for the down key binding map. */
    private static final String DOWN_STRING = "down";
    /** The string for the clockwise key binding map. */
    private static final String CW_STRING = "cw";
    /** The string for the counterclockwise key binding map. */
    private static final String CCW_STRING = "ccw";
    /** The string for the drop key binding map. */
    private static final String DROP_STRING = "drop";
    /** The preferred size of the game panel. */
    private static final Dimension PREFERRED_DIMENSION = new Dimension(400, 800);
    /** The amount of lines removed from the top of the Tetris board. */
    private static final int REMOVED_LINES = 4;
    /** The amount of padding for the inner square in each tetris block. */
    private static final int PADDING = 3;
    
    /** The size of the rendered block in pixels. */
    private int myBlockSize;
    
    /** The origin point of the rendered Tetris board. */
    private Point myOrigin;
    
    /** The Tetris game. */
    private final Board myTetris;
    
    /** The tetris data for block locations. */
    private List<Color[]> myGameData;
    
    /** The timer used to run the tetris game. */
    private final Timer myTimer;
    
    /** The key code for left key binding. */
    private int myLeftKey;
    
    /** The action for the left key binding. */
    private Action myLeftAction;
    
    /** The key code for the right key binding. */
    private int myRightKey;
    
    /** The action for the right key binding. */
    private Action myRightAction;
    
    /** The key code for the down key binding. */
    private int myDownKey;
    
    /** The action for the down key binding. */
    private Action myDownAction;
    
    /** The key code for the clockwise key binding. */
    private int myCWKey;
    
    /** The action for the clockwise key binding. */
    private Action myCWAction;
    
    /** The key code for the counterclockwise key binding. */
    private int myCCWKey;
    
    /** The action for the counterclockwise key binding. */
    private Action myCCWAction;
    
    /** The key code for the drop key binding. */
    private int myDropKey;
    
    /** The action for the drop key binding. */
    private Action myDropAction;
    
    /** Indicates that a game is over. */
    private boolean myGameIsOver;
    
    /** Game Over message. */
    private JLabel myMessage;
    
    
    /**
     * Builds the display panel for a game of tetris.
     * 
     * @param theTetris The tetris game.
     * @param theTimer The tetris game timer.
     */
    public GamePanel(final Board theTetris, final Timer theTimer) {
        super(true);  // Sets JPanel to enable double buffering.
        myTetris = theTetris;
        setBlockSize();
        myGameIsOver = false;
        myTimer = theTimer;
        startGameGUI();
    }
    
    
    /**
     * Calculates the rendered block size depending on the height and
     * width of the game panel.
     */
    private void setBlockSize() {
        final int blockHeightCheck = this.getHeight() / myTetris.getHeight();
        final int blockWidthCheck = this.getWidth() / myTetris.getWidth();
        
        if (blockHeightCheck < blockWidthCheck) {
            myBlockSize = blockHeightCheck;
        } else {
            myBlockSize = blockWidthCheck;
        }
    }
    
    /**
     * Initializes the panel for rendering the tetris game.
     */
    private void startGameGUI() {
        //this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        this.setPreferredSize(PREFERRED_DIMENSION);
        this.setBackground(Color.LIGHT_GRAY);
        

        myMessage = new JLabel("- GAME OVER -");
        myMessage.setFont(new Font("Verdana", 1, FONT_SIZE));
        myMessage.setForeground(Color.WHITE);
        add(myMessage);
        myMessage.setVisible(myGameIsOver);
        
        registerActions();
        // default key bindings
        myLeftKey = KeyEvent.VK_A;
        myRightKey = KeyEvent.VK_D;
        myDownKey = KeyEvent.VK_S;
        myCWKey = KeyEvent.VK_E;
        myCCWKey = KeyEvent.VK_Q;
        myDropKey = KeyEvent.VK_W;
        
        enableKeys();
    }
    
    
    /**
     * Stops the current game and signals a game over.
     */
    public void gameOver() {  
        disableKeys();
        myGameIsOver = true;
        repaint();
    }
    
    
    /**
     * Pauses the current game by stopping the timer
     * and disabling key bindings.
     */
    public void pause() {
        disableKeys();
        myTimer.stop();
    }
    
    
    /**
     * Unpauses the current game by starting the timer
     * and enabling key binding if only the game is not
     * over.
     */
    public void unpause() {
        if (!myGameIsOver) {
            enableKeys();
            myTimer.start();
        }
    }
    
    
    /**
     * Returns a map that contains the current key codes
     * for the key bindings.
     * 
     * @return Map of key codes.
     */
    public Map<String, Integer> getKeys() {
        final Map<String, Integer> keys = new TreeMap<String, Integer>();
        keys.put(LEFT_STRING, myLeftKey);
        keys.put(RIGHT_STRING, myRightKey);
        keys.put(DOWN_STRING, myDownKey);
        keys.put(CW_STRING, myCWKey);
        keys.put(CCW_STRING, myCCWKey);
        keys.put(DROP_STRING, myDropKey);
        return keys;
    }
    
    
    /**
     * Updates the key codes for key bindings using the passed
     * map of key codes.
     * 
     * @param theKeys The map of key codes.
     */
    public void setKeys(final Map<String, Integer> theKeys) {
        disableKeys();
        myLeftKey = theKeys.get(LEFT_STRING);
        myRightKey = theKeys.get(RIGHT_STRING);
        myDownKey = theKeys.get(DOWN_STRING);
        myCWKey = theKeys.get(CW_STRING);
        myCCWKey = theKeys.get(CCW_STRING);
        myDropKey = theKeys.get(DROP_STRING);
        if (!myGameIsOver) {
            enableKeys();
        }
    }
    
    
    /**
     * Disables key bindings.
     */
    private void disableKeys() {
        disableKey(myLeftKey);
        disableKey(myRightKey);
        disableKey(myDownKey);
        disableKey(myCWKey);
        disableKey(myCCWKey);
        disableKey(myDropKey);
    }
    
    /**
     * Enables key bindings.
     */
    private void enableKeys() {
        bindKey(myLeftAction, myLeftKey);
        bindKey(myRightAction, myRightKey);
        bindKey(myDownAction, myDownKey);
        bindKey(myCWAction, myCWKey);
        bindKey(myCCWAction, myCCWKey);
        bindKey(myDropAction, myDropKey);
    }
    
    
    /**
     * Registers abstract actions to the key binding actions.
     */
    private void registerActions() {
        myLeftAction = new AbstractAction() {
            @Override
            public void actionPerformed(final ActionEvent theEvent) {
                myTetris.left();
            }
        };
        
        myRightAction = new AbstractAction() {
            @Override
            public void actionPerformed(final ActionEvent theEvent) {
                myTetris.right();
            }
        };
        
        myDownAction = new AbstractAction() {
            @Override
            public void actionPerformed(final ActionEvent theEvent) {
                myTetris.down();
            }
        };
        
        myCWAction = new AbstractAction() {
            @Override
            public void actionPerformed(final ActionEvent theEvent) {
                myTetris.rotateCW();
            }
        };
        
        myCCWAction = new AbstractAction() {
            @Override
            public void actionPerformed(final ActionEvent theEvent) {
                myTetris.rotateCCW();
            }
        };
        
        myDropAction = new AbstractAction() {
            @Override
            public void actionPerformed(final ActionEvent theEvent) {
                myTetris.drop();
            }
        };
    }
    
    /**
     * Binds an action to a given key.
     * 
     * @param theAction The action that will be bound.
     * @param theKey The key code that will be bound.
     */
    public void bindKey(final Action theAction, final int theKey) {
        getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(theKey, 0),
                                                theAction.toString());
        getActionMap().put(theAction.toString(), theAction);
    }
    
    
    /**
     * Disables a key binding.
     * 
     * @param theKey The key code that will be disabled.
     */
    public void disableKey(final int theKey) {
        getInputMap(WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(theKey, 0), "none");
    }
    
    
    @Override
    public void paintComponent(final Graphics theGraphics) {
        super.paintComponent(theGraphics);
        final Graphics2D graphic = (Graphics2D) theGraphics;
        graphic.setRenderingHint(RenderingHints.KEY_ANTIALIASING, 
                                 RenderingHints.VALUE_ANTIALIAS_ON);
        
        //System.out.println(myBlockSize);
        setBlockSize();
        
        // Centers the game panel for resizing.
        final Point center = new Point(myTetris.getWidth() * myBlockSize / 2,
                                       myTetris.getHeight() * myBlockSize / 2);
        final Point panelCenter = new Point(this.getWidth() / 2, this.getHeight() / 2);
        myOrigin = new Point(panelCenter.x() - center.x(), panelCenter.y() - center.y());
        // Draws the game backdrop.
        graphic.setPaint(Color.BLACK);
        graphic.fillRect(myOrigin.x(), myOrigin.y(), center.x() * 2, center.y() * 2);
        
        // Draws the board through a 2d array for the coordinates.
        for (int y = 0; y < myGameData.size() - REMOVED_LINES; y++) {
            for (int x = 0; x < myGameData.get(y).length; x++) {
                drawBlock(x, y, graphic);
            }
        }
        // Draws a game over message when the game is over.
        if (myGameIsOver) {
            myMessage.setVisible(myGameIsOver);
        }
    }
    
    /**
     * Draws a single tetris block.
     * 
     * @param theX The x coordinate of the block.
     * @param theY The y coordinate of the block.
     * @param theGraphics The graphics.
     */
    private void drawBlock(final int theX, final int theY, final Graphics2D theGraphics) {
        if (myGameData.get(theY)[theX] != null) {
            theGraphics.setPaint(myGameData.get(theY)[theX]);
            theGraphics.fillRect(theX * myBlockSize + myOrigin.x(),
                      (myTetris.getHeight() - theY - 1) * myBlockSize + myOrigin.y(),
                      myBlockSize,
                      myBlockSize);
            theGraphics.setPaint(Color.BLACK);
            theGraphics.drawRect(theX * myBlockSize + myOrigin.x() + PADDING,
                      (myTetris.getHeight() - theY - 1) * myBlockSize + myOrigin.y() + PADDING,
                      myBlockSize - (PADDING * 2),
                      myBlockSize - (PADDING * 2));
        }
    }
    
    
    @Override
    public void update(final Observable theObj, final Object theArg) {
        if (theArg instanceof BoardData) {
            myGameData = ((BoardData) theArg).getBoardData();
        }
        repaint();
        //System.out.println(myTetris);
    }
    
    
} // end of GamePanel


